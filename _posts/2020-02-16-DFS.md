---
layout: post
title:  study
date:   2020-02-01
categories: STUDY 
---

<!-- MarkdownTOC -->




#算法
## DFS
![题目](https://s2.ax1x.com/2020/02/16/39Juin.png)
此题有多种方法，自此用几种方法来熟悉：

1.中序遍历

通过中序遍历来保存这个二叉树的值，可以发现如果为中序遍历保存这些值的话，他们为单调递增排列，那么判断是否为二叉搜索树只需要比较相邻结点即可，从这个思路我们可以得到

```
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
```
```
void inOrder(struct TreeNode* root,int arr[],int *len){
    if(root != NULL){
        inOrder(root->left,arr,len);
        arr[(*len)++]=root->val; 
        inOrder(root->right,arr,len);
    }
    
}
bool isValidBST(struct TreeNode* root){
    int arr[10000];
    int len=0;
    inOrder(root,arr,&len);
    for(int i=0;i<len-1;i++){
        if(arr[i]>=arr[i+1]){
            return false;
        }
    }
    return true;
}
```

2.卡左右边界

![思路](https://s2.ax1x.com/2020/02/17/3ieacQ.png)

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def isValidBST(self, root: TreeNode, low = float('-inf'), high = float('inf')) -> bool:
        if not root:return True
        if not low<root.val<high:return False
        return self.isValidBST(root.left,low,root.val) and self.isValidBST(root.right,root.val,high)
```

3.递归栈

```
bool isValidBST(TreeNode* root) {
    stack<TreeNode *> __stack;//栈初始化
    TreeNode *pre = nullptr;//空指针
    // 迭代的方式中序遍历
    while(root || !__stack.empty()) {
        while (root) {
            __stack.push(root);
            root = root->left;
        }
        
        root = __stack.top();
        __stack.pop();
        
        if (pre && pre->val >= root->val) {
            return false;
        }
        pre = root;
        root = root->right;
    }
    
    return true;
    
 ```

